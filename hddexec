#!/bin/bash
IFS=$'\n'

: '	HDDMAIL v.1.2 by admiral-vulcan
 2020

	Changelog:
	1.1	FIXED	changed crontab.
	1.2	FIXED	"Error: No error" - error
	1.2	ADDED	tab completion in bash
	
	see above in function writeHddmail

	todo:
	add version check for updates
	
	
'

clear

version="1.2"
errorfound=0
option=$1
option=${option,,}
opttwo=$2

readonly BASE_DIR="/opt/hddmailFiles"
readonly EXEC_PATH="$BASE_DIR/hddexec"
readonly CFG_PATH="$BASE_DIR/hddmail.cfg"
readonly STATUS_STORE_PATH="$BASE_DIR/hddsmart_status.json"

if [[ -d /bin/hddmailFiles && ! -d "$BASE_DIR" ]]; then
        echo "Migrating old /bin/hddmailFiles to $BASE_DIR..."
        mkdir -p "$BASE_DIR"
        mv /bin/hddmailFiles/* "$BASE_DIR"/ 2>/dev/null || true
        rm -rf /bin/hddmailFiles
fi

if [[ ! -d "$BASE_DIR" ]]
then
        mkdir -p "$BASE_DIR"
fi

if [[ -f "$STATUS_STORE_PATH" ]]
then
        if ! python3 - "$STATUS_STORE_PATH" <<'PY' >/dev/null 2>&1
import json
import sys
from pathlib import Path

path = Path(sys.argv[1])
try:
        content = path.read_text(encoding="utf-8")
except FileNotFoundError:
        sys.exit(1)
if not content.strip():
        sys.exit(1)
try:
        data = json.loads(content)
except json.JSONDecodeError:
        sys.exit(1)
if not isinstance(data, dict):
        sys.exit(1)
PY
        then
                echo "{}" > "$STATUS_STORE_PATH"
        fi
else
        echo "{}" > "$STATUS_STORE_PATH"
fi

function chkoption {
	if [[ ! $opttwo == "" ]]
	then
		echo ""
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  error"
		echo "******************************************"
		echo ""
		echo "Please pass only one option at a time. Exiting."
		exit 1
	fi


	if [[ ! ($option == "" || $option == "-h" || $option == "--help" || $option == "--daily" || $option == "--weekly" || $option == "--config" || $option == "--status" || $option == "--summary" || $option == "--sendmail" || $option == "--viewcfg") ]]
	then
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  error"
		echo "******************************************"
		echo ""
		echo "Option not recognized. Exiting."
		exit 1
	fi

	if [[ $option == "-h" ]]
	then
		option="--help"
	fi
}

function chkhome {
        if [ ! -e "$EXEC_PATH" ] #installation executes HERE
	then
		echo ""
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  auto install"
		echo "******************************************"
		echo ""
                writeHddmail
                date > "$BASE_DIR/install.log"
                echo "Created program directory $BASE_DIR/ and install.log" >> "$BASE_DIR/install.log"
                mv "$(readlink -f "$0")" "$EXEC_PATH" >> "$BASE_DIR/install.log"
                echo "Moved program file hddmail to program directory." >> "$BASE_DIR/install.log"

                if [ -e /usr/local/bin/hddmail ] || [ -L /usr/local/bin/hddmail ]
                then
                        rm -f /usr/local/bin/hddmail
                fi

                if [ -e /bin/hddmail ] || [ -L /bin/hddmail ]
                then
                        rm -f /bin/hddmail
                fi

                ln -sf "$BASE_DIR/hddmail" /usr/local/bin/hddmail >> "$BASE_DIR/install.log"

                echo "Created hddmail symlink in /usr/local/bin/" >> "$BASE_DIR/install.log"

                complete -W '-h --help --sendmail --weekly --daily --config --viewcfg --status --summary --resetstore' hddmail
                echo "Created tab completion entry via complete" >> "$BASE_DIR/install.log"

                chmod 755 -R "$BASE_DIR"
                if [[ -f "$STATUS_STORE_PATH" ]]
                then
                        chmod 644 "$STATUS_STORE_PATH"
                fi
                if [[ -f "$CFG_PATH" ]]
                then
                        chmod 600 "$CFG_PATH"
                fi

                echo "HDDMAIL has been installed." >> "$BASE_DIR/install.log"
                echo "HDDMAIL has been installed."
                echo "An install log has been written in $BASE_DIR/install.log"
                echo ""
                echo "HDDMAIL needs to be configured."
                read -r -p "Do you wish to configure it now? [Y/n]" response
                response=${response,,} # tolower
                if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]
                then
                        "$BASE_DIR/hddmail" --config
                else
                        echo ""
                        echo "You chose not to configure HDDMAIL."
			echo "Enter hddmail --config for program configuration."
			echo "Enter hddmail --help for more info."
			echo  "Exiting."
			exit 0
		fi
		exit 0
	fi
}

function chkln {
        if [ ! -e /usr/local/bin/hddmail ] && [ ! -L /usr/local/bin/hddmail ]
        then
                ln -sf "$BASE_DIR/hddmail" /usr/local/bin/hddmail > /dev/null
        fi
}

function chkconfig {
        miscfg=0
        mailerr=0
        hdderr=0
        if [ ! -e "$CFG_PATH" ]
        then
        miscfg=1
        fi
        nummail=$(grep -E -c '^[[:space:]]*(To|From):.*@' "$CFG_PATH")
        #numhdd=$(grep -c "/dev/sd" "$CFG_PATH") #old method not working with /dev/disk/by-id
        numhdd=$(sed "4q;d" "$CFG_PATH" | cut -c19-)
        #cfgver=$(sed "0q;d" "$CFG_PATH" | cut -c19-)
	if [[ ! $nummail -eq 2 ]] 
	then
		mailerr=1
	fi
	
	if [[ ! $numhdd -ge 1 ]] 
	then
		hdderr=1
	fi
	errcount=$((miscfg+mailerr+hdderr))
	if [[ $errcount -gt 0 ]]
	then
	clear
		echo ""
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  error"
		echo "******************************************"
		echo ""

	
		if [[ $miscfg -gt 0 ]]
		then
			echo "Configfile hddmail.cfg is missing. Enter hddmail --help for more info."
			echo "Exiting."
			exit 1
		fi
		
		if [[ $mailerr -gt 0 ]]
		then
			echo "Could not find valid E-Mail addresses in the config file."
		fi
		
		if [[ $hdderr -gt 0 ]]
		then
			echo "No HDDs specified in configfile."
		fi
		
		echo "Exiting"
		exit 1
	fi	
}

function readconfig {
        tomailline=$(grep "To" "$CFG_PATH")
        frommailline=$(grep "From" "$CFG_PATH")
        dest=$(grep "To" "$CFG_PATH" | cut -c5-)
	# got numhdd from chkconfig
}

function helpmode {
	echo ""
	echo "******************************************"
	echo "HDDMAIL v.1.2 by admiral-vulcan
  help"
	echo "******************************************"
	echo ""
	echo "Options: "
	echo "	-h, --help	for this info"
	echo "	--sendmail	for status report per mail"
	echo "	--weekly	designed for scheduler: send weekly mail report"
	echo "	--daily 	designed for scheduler: send daily mail only if errors were found"
	echo "	--config	for program configuration"
	echo "	--viewcfg	for program to print config file"
	echo "	--status	for program to show hdd full health status"	
	echo "	--summary	for program to show hdd summary"	
	echo "	--resetstore	reset SMART status tracking store"	
	echo ""
	echo "Note: Errors are only reported if new or growing SMART issues have been detected."
}

function configmode {
	echo ""
	echo "******************************************"
	echo "HDDMAIL v.1.2 by admiral-vulcan
  configuration"
	echo "******************************************"
	echo ""
	echo "Checking dependencies, please wait."
	
	
	hddapp=$(dpkg-query -W --showformat='${Status}\n' smartmontools | grep "install ok installed")
	if [ "" == "$hddapp" ]
	then
		echo "Smartmontools are not installed. This program will not work without them."
		read -r -p "Do you wish to install it? No will abort this installation. [Y/n]" response
		response=${response,,} # tolower
		if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]
		then
			apt-get -y install smartmontools
		else
			echo "You chose not to install smartmontools. Exiting."
			exit 0
		fi
	fi
	
	mailapp=$(dpkg-query -W --showformat='${Status}\n' msmtp | grep "install ok installed")
	if [ "" == "$mailapp" ]
	then
		echo "The mail program msmtp is not installed." 
		echo "While this program CAN also work with different mail programs" 
		echo "that are compatible with the sendmail - syntax," 
		echo "it is tested with msmtp only and therefore highly recommended to use."
		read -r -p "Do you wish to install it? [Y/n]" response
		response=${response,,} # tolower
		if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]
		then
			apt-get -y update && apt-get upgrade -V
			apt-get -y install msmtp msmtp-mta mailutils
			mv /usr/sbin/sendmail /usr/sbin/sendmail.bak
			ln -s /usr/bin/msmtp /usr/sbin/sendmail
			ln -s /usr/bin/msmtp /bin/sendmail
			egmailacc
			echo "The program msmtp has been installed"
			echo "and an example-config named \"gmx-some-name\""
			echo "written in  \"/etc/msmtprc\". Change it accordingly."
		else
			echo "You chose not to install msmtp. Good luck."
		fi
	fi
	
	
        echo "Version: $version" > "$CFG_PATH"
	echo ""
	echo ""
	echo "Done checking dependencies."
	echo ""
	echo "Enter destination E-Mail for the TO state"
	read dest
	echo ""
	echo "Enter source E-Mail for the FROM state"
	echo "(This should match your mail-program-settings)"
	read source
	echo ""
        echo "To: $dest" >> "$CFG_PATH"
        echo "From: $source" >> "$CFG_PATH"
        grep "To" "$CFG_PATH"
        grep "From" "$CFG_PATH"
	echo "Addresses saved"	
	echo ""
	echo "Scanning for drives . . ."
	echo ""
	gethdds
        numlsblk=$(grep -c "sd" "$BASE_DIR/listlsblk.txt")
        nummdadm=$(grep -c "sd" "$BASE_DIR/listmdadm.txt")
	echo "Found a total of $numlsblk drives on your system of which $nummdadm are in a RAID."
	echo ""
	echo "Do you wish to observe all drives [A] or the ones in your RAID only [r]?"
	echo ""
	echo "Notes:" 
	echo "The /dev/sd* mapping may vary. Observing all drives is recomended."
	echo "If you know that your non-RAID drives do not support SMART, choose [r]"
	echo ""
        echo "HDDMAIL is compatible with drive id. You can change the drives"
        echo "to /dev/disk/by-id/*your-drive* in $CFG_PATH later."
	echo ""
	read -r -p "Please choose: [A/r]" response
	response=${response,,} # tolower
	if [[ $response =~ ^(all|a| ) ]] || [[ -z $response ]]
	then
		#use lsblklist
                echo "Number of drives: $numlsblk" >> "$CFG_PATH"
		i=1
		while [[ $i -le $numlsblk ]]
		do
                        echo "writing /dev/$(sed "${i}q;d" "$BASE_DIR/listlsblk.txt") to config-file."
                        echo "/dev/$(sed "${i}q;d" "$BASE_DIR/listlsblk.txt")" >> "$CFG_PATH"
			i=$((i+1))
		done
	else
		#use mdadmlist
                echo "Number of drives: $nummdadm" >> "$CFG_PATH"
		i=1
		while [[ $i -le $nummdadm ]]
		do
                        echo "writing /dev/$(sed "${i}q;d" "$BASE_DIR/listmdadm.txt") to config-file."
                        echo "/dev/$(sed "${i}q;d" "$BASE_DIR/listmdadm.txt")" >> "$CFG_PATH"
			i=$((i+1))
		done
	fi	
	
	read -r -p "Do you want the scheduler to be set into crontab? [Y/n]" response
	response=${response,,} # tolower
	if [[ $response =~ ^(yes|y| ) ]] || [[ -z $response ]]
	then
		if  crontab -l | grep -q 'hddmail'
		then 
			echo "Scheduler already set." 
		else
			(crontab -l 2>/dev/null; echo "0 4 * * 7   $BASE_DIR/hddmail --weekly > /dev/null 2>&1") | crontab -
			(crontab -l 2>/dev/null; echo "0 4 * * 1-6 $BASE_DIR/hddmail --daily  > /dev/null 2>&1") | crontab -
			echo 'The scheduler is set to daily silent scans at 4 AM and a weekly status report every Sunday.'
			echo 'You can change this by editing your contab via \"crontab -e\".'
		fi
	else
		echo "You can manually set it via crontab -e."
	fi
	
        chmod 755 -R "$BASE_DIR"
        if [[ -f "$STATUS_STORE_PATH" ]]
        then
                chmod 644 "$STATUS_STORE_PATH"
        fi
        if [[ -f "$CFG_PATH" ]]
        then
                chmod 600 "$CFG_PATH"
        fi
	
	echo ""

	echo ""
	echo "Exiting configuration."
}

function viewcfgmode {
        if [ ! -e "$CFG_PATH" ]
        then
                echo ""
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  error"
		echo "******************************************"
		echo ""
		echo "No config file found. Please run config. Enter hddmail --help for more info."
		echo "Exiting."
		exit 1
	else
		echo ""
		echo "******************************************"
		echo "HDDMAIL v.1.2 by admiral-vulcan
  print config"
		echo "******************************************"
		echo ""

                cat "$CFG_PATH"
		echo ""
		echo "Exiting."
		exit 0
		
	fi
}

function resetstore {
        echo "{}" > "$STATUS_STORE_PATH"
        chmod 644 "$STATUS_STORE_PATH"
        echo "SMART status store has been reset."
}

function modejumper {
        if [[ $option == "--help" ]]
        then
                helpmode
                exit 0
        elif [[ $option == "--config" ]]
        then
                configmode
                exit 0
        elif [[ $option == "--viewcfg" ]]
        then
                viewcfgmode
                exit 0
        elif [[ $option == "--resetstore" ]]
        then
                resetstore
                exit 0
        fi
}

function domagic {
        echo ""
        echo "******************************************"
        echo "HDDMAIL v.1.2 by admiral-vulcan"
        echo "******************************************"
        echo ""
        echo "Reading SMART values. Please wait."
        echo ""

        echo "" > "$BASE_DIR/hddsummary.txt"
        echo "" > "$BASE_DIR/hddstatus.txt"

        issue_devices=0

        COUNTER=0
        while [[  $COUNTER -lt $numhdd ]]
        do
                currenthdd="$(sed "$((COUNTER+5))q;d" "$CFG_PATH")"
                smart_tmp="$(mktemp)"
                smart_err="$(mktemp)"

                if /usr/sbin/smartctl -j "$currenthdd" > "$smart_tmp" 2> "$smart_err"
                then
                        # Python SMART exit codes:
                        # 0 = OK
                        # 1 = existing issue (already known)
                        # 2 = new issue detected
                        # 3 = parsing or runtime error
                        python3 - "$currenthdd" "$smart_tmp" \
                                "$BASE_DIR/hddsummary.txt" "$BASE_DIR/hddstatus.txt" "$STATUS_STORE_PATH" <<'PY'
import json
import sys
import time
from pathlib import Path

DEFAULT_STATUS_LINE = "No critical SMART issues detected."


def load_json(path: Path):
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def load_store(path: Path):
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        return {}
    except json.JSONDecodeError:
        return {}
    if isinstance(data, dict):
        return data
    return {}


def dump_store(path: Path, content: dict):
    tmp_path = path.with_suffix(path.suffix + ".tmp")
    with tmp_path.open("w", encoding="utf-8") as handle:
        json.dump(content, handle, indent=2, sort_keys=True)
        handle.write("\n")
    tmp_path.replace(path)


def mark_event(events: dict, name: str, value: int):
    events[name] = int(value)


def main():
    drive, json_path, summary_path, status_path, store_path = sys.argv[1:6]

    data = load_json(Path(json_path))
    summary_lines = []
    status_lines = []
    events = {}

    smart_status = data.get("smart_status", {})
    passed = smart_status.get("passed") if isinstance(smart_status, dict) else None
    if passed is True:
        summary_lines.append("SMART overall-health: PASSED")
        mark_event(events, "smart_status_failed", 0)
        status_state = "PASSED"
    elif passed is False:
        summary_lines.append("SMART overall-health: FAILED")
        status_lines.append("SMART overall-health check reports FAILURE")
        mark_event(events, "smart_status_failed", 1)
        status_state = "FAILED"
    else:
        summary_lines.append("SMART overall-health: UNKNOWN")
        mark_event(events, "smart_status_failed", 0)
        status_state = "UNKNOWN"

    power_on = data.get("power_on_time", {})
    power_on_hours = None
    if isinstance(power_on, dict):
        power_on_hours = power_on.get("hours")
    if isinstance(power_on_hours, (int, float)):
        summary_lines.append(f"Power-on Hours: {int(power_on_hours)} h")

    temperature_line = None
    temperature = data.get("temperature")
    if isinstance(temperature, dict):
        current_temp = temperature.get("current")
        if isinstance(current_temp, (int, float)):
            temperature_line = f"Temperature: {int(current_temp)} °C"
    if temperature_line is None:
        nvme_log = data.get("nvme_smart_health_information_log")
        if isinstance(nvme_log, dict):
            nvme_temp = nvme_log.get("temperature")
            if isinstance(nvme_temp, (int, float)):
                nvme_temp_c = int(nvme_temp - 273) if nvme_temp > 200 else int(nvme_temp)
                temperature_line = f"Temperature: {nvme_temp_c} °C"
    if temperature_line:
        summary_lines.append(temperature_line)

    ata_error_count = data.get("ata_error_count")
    if isinstance(ata_error_count, int):
        mark_event(events, "ata_error_count", ata_error_count)
        if ata_error_count > 0:
            status_lines.append(f"ATA error count: {ata_error_count}")
    else:
        mark_event(events, "ata_error_count", 0)

    RAW_CRITICAL = {
        "Reallocated_Sector_Ct",
        "Reallocated_Event_Count",
        "Current_Pending_Sector",
        "Offline_Uncorrectable",
        "Reported_Uncorrect",
        "Uncorrectable_Error_Cnt",
        "Command_Timeout",
        "End-to-End_Error",
    }

    udma_crc_recorded = False
    ata_attributes = data.get("ata_smart_attributes", {})
    attr_table = ata_attributes.get("table") if isinstance(ata_attributes, dict) else None
    if isinstance(attr_table, list):
        for attribute in attr_table:
            if not isinstance(attribute, dict):
                continue
            name = attribute.get("name") or f"ID-{attribute.get('id')}"
            when_failed = attribute.get("when_failed")
            flags = attribute.get("flags") if isinstance(attribute.get("flags"), dict) else {}
            prefailure = bool(flags.get("prefailure"))
            thresh = attribute.get("thresh")
            value = attribute.get("value")
            raw = attribute.get("raw") if isinstance(attribute.get("raw"), dict) else {}
            raw_value = raw.get("value")

            if when_failed and when_failed != "-":
                status_lines.append(f"{name}: previously failed ({when_failed})")
                mark_event(events, f"attr_failed::{name}", 1)

            if isinstance(thresh, int) and isinstance(value, int) and value <= thresh and prefailure:
                status_lines.append(f"{name}: value {value} at/below threshold {thresh}")
                mark_event(events, f"attr_threshold::{name}", int(value))

            if isinstance(raw_value, int):
                if prefailure and raw_value > 0:
                    status_lines.append(f"{name}: raw value {raw_value}")
                    mark_event(events, f"attr_raw::{name}", int(raw_value))
                elif name in RAW_CRITICAL and raw_value > 0:
                    status_lines.append(f"{name}: raw value {raw_value}")
                    mark_event(events, f"attr_raw::{name}", int(raw_value))

                if name == "UDMA_CRC_Error_Count":
                    mark_event(events, "udma_crc_error_count", int(raw_value))
                    udma_crc_recorded = True

    if not udma_crc_recorded:
        mark_event(events, "udma_crc_error_count", 0)

    nvme_log = data.get("nvme_smart_health_information_log")
    if isinstance(nvme_log, dict):
        critical_warning = nvme_log.get("critical_warning")
        if isinstance(critical_warning, int):
            mark_event(events, "nvme_critical_warning", critical_warning)
            if critical_warning != 0:
                status_lines.append(f"NVMe critical warning flags set: {critical_warning}")
        else:
            mark_event(events, "nvme_critical_warning", 0)

        nvme_checks = {
            "media_errors": "NVMe media errors",
            "num_err_log_entries": "NVMe error log entries",
            "unsafe_shutdowns": "NVMe unsafe shutdowns",
        }
        for key, label in nvme_checks.items():
            value = nvme_log.get(key)
            if isinstance(value, int):
                mark_event(events, f"nvme_{key}", value)
                if value > 0:
                    status_lines.append(f"{label}: {value}")
            else:
                mark_event(events, f"nvme_{key}", 0)

        spare = nvme_log.get("available_spare")
        spare_threshold = nvme_log.get("available_spare_threshold")
        if isinstance(spare, int) and isinstance(spare_threshold, int) and spare <= spare_threshold:
            status_lines.append(
                f"NVMe available spare {spare}% at/below threshold {spare_threshold}%"
            )
            mark_event(events, "nvme_spare_below_threshold", 1)
        else:
            mark_event(events, "nvme_spare_below_threshold", 0)

        percentage_used = nvme_log.get("percentage_used")
        if isinstance(percentage_used, int):
            mark_event(events, "nvme_percentage_used", percentage_used)
            if percentage_used >= 100:
                status_lines.append(f"NVMe percentage used: {percentage_used}%")
        else:
            mark_event(events, "nvme_percentage_used", 0)
    else:
        mark_event(events, "nvme_critical_warning", 0)
        mark_event(events, "nvme_media_errors", 0)
        mark_event(events, "nvme_num_err_log_entries", 0)
        mark_event(events, "nvme_unsafe_shutdowns", 0)
        mark_event(events, "nvme_spare_below_threshold", 0)
        mark_event(events, "nvme_percentage_used", 0)

    if not summary_lines:
        summary_lines.append("No SMART summary information available.")

    if not status_lines:
        status_lines.append(DEFAULT_STATUS_LINE)

    with open(summary_path, "a", encoding="utf-8") as summary_file:
        summary_file.write(f"Summary of {drive}:\n")
        for line in summary_lines:
            summary_file.write(f"  - {line}\n")
        summary_file.write("\n")

    with open(status_path, "a", encoding="utf-8") as status_file:
        status_file.write(f"Status of {drive}:\n")
        for line in status_lines:
            status_file.write(f"  - {line}\n")
        status_file.write("\n")

    store_path_obj = Path(store_path)
    store = load_store(store_path_obj)
    prev = store.get(drive, {}) if isinstance(store, dict) else {}
    prev_events = prev.get("events", {}) if isinstance(prev, dict) else {}

    new_issue = False
    for name, value in events.items():
        try:
            previous_value = int(prev_events.get(name, 0))
        except (TypeError, ValueError):
            previous_value = 0
        if int(value) > previous_value:
            new_issue = True

    store[drive] = {
        "events": events,
        "smart_status": status_state,
        "updated": int(time.time()),
    }
    dump_store(store_path_obj, store)

    has_warning = any(line != DEFAULT_STATUS_LINE for line in status_lines)
    if has_warning:
        return 2 if new_issue else 1
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except Exception as exc:  # pylint: disable=broad-except
        drive = sys.argv[1]
        status_path = sys.argv[4]
        with open(status_path, "a", encoding="utf-8") as status_file:
            status_file.write(f"Status of {drive}:\n")
            status_file.write("  - SMART data parsing failed.\n")
            status_file.write(f"    {exc}\n\n")
        sys.exit(3)
PY
                        py_status=$?
                        if [[ $py_status -eq 2 ]]
                        then
                                issue_devices=$((issue_devices+1))
                                errorfound=1
                                logger -t hddmail "SMART error detected on $currenthdd"
                        elif [[ $py_status -eq 1 ]]
                        then
                                issue_devices=$((issue_devices+1))
                                logger -t hddmail "SMART error detected on $currenthdd"
                        elif [[ $py_status -ne 0 ]]
                        then
                                errorfound=1
                                issue_devices=$((issue_devices+1))
                                logger -t hddmail "SMART error detected on $currenthdd"
                                echo "Status of $currenthdd:" >> "$BASE_DIR/hddstatus.txt"
                                echo "  - SMART data parsing failed." >> "$BASE_DIR/hddstatus.txt"
                                echo "" >> "$BASE_DIR/hddstatus.txt"
                        fi
                else
                        logger -t hddmail "SMART error detected on $currenthdd"
                        echo "Summary of $currenthdd:" >> "$BASE_DIR/hddsummary.txt"
                        echo "  - SMART data could not be retrieved." >> "$BASE_DIR/hddsummary.txt"
                        echo "" >> "$BASE_DIR/hddsummary.txt"

                        echo "Status of $currenthdd:" >> "$BASE_DIR/hddstatus.txt"
                        echo "  - smartctl returned an error:" >> "$BASE_DIR/hddstatus.txt"
                        sed 's/^/    /' "$smart_err" >> "$BASE_DIR/hddstatus.txt"
                        echo "" >> "$BASE_DIR/hddstatus.txt"
                        errorfound=1
                        issue_devices=$((issue_devices+1))
                fi

                rm -f "$smart_tmp" "$smart_err"
                let COUNTER=COUNTER+1
        done

        echo "Structured summary stored in $BASE_DIR/hddsummary.txt"
        echo "Structured status stored in $BASE_DIR/hddstatus.txt"
        echo ""
}

function makemail {

        echo "$tomailline" > "$BASE_DIR/hddmailhead.txt"
        echo "$frommailline" >> "$BASE_DIR/hddmailhead.txt"

        if [[ $issue_devices -gt 0 ]]
        then
                if [[ $issue_devices -eq 1 ]]
                then
                        subject="HDD SMART WARNUNG (1 Laufwerk betroffen)"
                else
                        subject="HDD SMART WARNUNG ($issue_devices Laufwerke betroffen)"
                fi
        elif [[ $errorfound -ne 0 ]]
        then
                subject="HDD SMART WARNUNG (Analysefehler)"
        else
                subject="HDD SMART Status Report"
        fi

        echo "Subject: $subject" >> "$BASE_DIR/hddmailhead.txt"
        echo "Content-Type: text/html; charset=UTF-8" >> "$BASE_DIR/hddmailhead.txt"
        echo "MIME-Version: 1.0" >> "$BASE_DIR/hddmailhead.txt"
        echo "" >> "$BASE_DIR/hddmailhead.txt"

        echo "<html>" >> "$BASE_DIR/hddmailhead.txt"
        echo "<style>" >> "$BASE_DIR/hddmailhead.txt"
        echo "body { font-family: Arial, sans-serif; background-color: #f5f7fa; margin: 0; padding: 16px; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "h1, h2 { color: #003049; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "table.smart-table { border-collapse: collapse; width: 100%; margin-bottom: 16px; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "table.smart-table th, table.smart-table td { border: 1px solid #d0d5dd; padding: 6px 10px; text-align: left; vertical-align: top; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "table.smart-table tr.ok { background-color: #d1e7dd; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "table.smart-table tr.warning { background-color: #f8d7da; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "table.smart-table tr.notice { background-color: #fff3cd; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "pre { background-color: #ffffff; border: 1px solid #d0d5dd; padding: 12px; overflow-x: auto; }" >> "$BASE_DIR/hddmailhead.txt"
        echo "</style>" >> "$BASE_DIR/hddmailhead.txt"
        echo "<body>" >> "$BASE_DIR/hddmailhead.txt"

        echo "******************************************" > "$BASE_DIR/hddmail.txt"
        echo "HDDMAIL v.1.2 by admiral-vulcan" >> "$BASE_DIR/hddmail.txt"
        echo "******************************************" >> "$BASE_DIR/hddmail.txt"
        echo "" >> "$BASE_DIR/hddmail.txt"
        date  >> "$BASE_DIR/hddmail.txt"
        echo "" >> "$BASE_DIR/hddmail.txt"
        echo "" >> "$BASE_DIR/hddmail.txt"

        if [[ $option == "--daily" ]]
        then
                echo "Report triggered by auto daily event." >> "$BASE_DIR/hddmail.txt"
        elif [[ $option == "--weekly" ]]
        then
                echo "Report triggered by auto weekly event." >> "$BASE_DIR/hddmail.txt"
        elif [[ $option == "--sendmail" ]]
        then
                echo "Report triggered by manual sendmail event." >> "$BASE_DIR/hddmail.txt"
        fi

        if [[ $issue_devices -gt 0 ]]
        then
                echo "$issue_devices monitored drive(s) reported SMART warnings." >> "$BASE_DIR/hddmail.txt"
        elif [[ $errorfound -ne 0 ]]
        then
                echo "SMART report contains parser errors. Please review manually." >> "$BASE_DIR/hddmail.txt"
        else
                echo "All monitored drives reported healthy SMART status." >> "$BASE_DIR/hddmail.txt"
        fi

        echo "" >> "$BASE_DIR/hddmail.txt"
        cat "$BASE_DIR/hddsummary.txt" >> "$BASE_DIR/hddmail.txt"
        echo "" >> "$BASE_DIR/hddmail.txt"
        cat "$BASE_DIR/hddstatus.txt" >> "$BASE_DIR/hddmail.txt"

        python3 - "$BASE_DIR/hddsummary.txt" "$BASE_DIR/hddstatus.txt" "$BASE_DIR/hddmail.txt" "$issue_devices" "$numhdd" "$BASE_DIR/hddmailbody.html" <<'PY'
import html
import sys
from pathlib import Path

summary_path, status_path, text_path, issues_raw, total_raw, html_out = sys.argv[1:7]

issues_count = int(issues_raw)
try:
    total_devices = int(total_raw)
except ValueError:
    total_devices = 0

def parse_sections(path: Path, prefix: str):
    sections = {}
    current = None
    if not path.exists():
        return sections
    for line in path.read_text(encoding="utf-8").splitlines():
        if line.startswith(prefix):
            current = line[len(prefix):].strip()
            sections[current] = []
        elif line.startswith("  -") and current is not None:
            sections.setdefault(current, []).append(line[4:])
    return sections

summary_sections = parse_sections(Path(summary_path), "Summary of ")
status_sections = parse_sections(Path(status_path), "Status of ")
all_devices = sorted(set(summary_sections) | set(status_sections))

rows = []
problematic_devices = 0
for device in all_devices:
    summary_lines = summary_sections.get(device, [])
    status_lines = status_sections.get(device, [])
    if not status_lines:
        row_class = "notice"
    elif any(line != "No critical SMART issues detected." for line in status_lines):
        row_class = "warning"
        problematic_devices += 1
    else:
        row_class = "ok"
    summary_html = "<br>".join(html.escape(line) for line in summary_lines) if summary_lines else "&ndash;"
    status_html = "<br>".join(html.escape(line) for line in status_lines) if status_lines else "Keine Daten verfügbar"
    rows.append((row_class, html.escape(device), summary_html, status_html))

if not all_devices:
    total_devices = max(total_devices, 0)
    problematic_devices = issues_count
else:
    total_devices = len(all_devices)
    if issues_count and issues_count > problematic_devices:
        problematic_devices = issues_count

text_content = Path(text_path).read_text(encoding="utf-8")
text_html = html.escape(text_content)

with Path(html_out).open("w", encoding="utf-8") as handle:
    handle.write("<h1>SMART-Auswertung</h1>\n")
    if total_devices:
        handle.write(
            f"<p>Betroffene Laufwerke: {problematic_devices} von {total_devices}</p>\n"
        )
    else:
        handle.write(
            f"<p>Betroffene Laufwerke: {problematic_devices}</p>\n"
        )
    handle.write("<table class=\"smart-table\">\n")
    handle.write("  <thead><tr><th>Laufwerk</th><th>Zusammenfassung</th><th>SMART-Warnungen</th></tr></thead>\n")
    handle.write("  <tbody>\n")
    if rows:
        for row_class, device, summary_html, status_html in rows:
            handle.write(
                f"    <tr class=\"{row_class}\"><td>{device}</td><td>{summary_html}</td><td>{status_html}</td></tr>\n"
            )
    else:
        handle.write("    <tr class=\"notice\"><td colspan=\"3\">Keine SMART-Daten verfügbar.</td></tr>\n")
    handle.write("  </tbody>\n</table>\n")
    handle.write("<h2>Detailauswertung (Text)</h2>\n")
    handle.write(f"<pre>{text_html}</pre>\n")
PY

        cat "$BASE_DIR/hddmailhead.txt" > "$BASE_DIR/hddmailsend.txt"
        cat "$BASE_DIR/hddmailbody.html" >> "$BASE_DIR/hddmailsend.txt"
        echo "</body></html>" >> "$BASE_DIR/hddmailsend.txt"

        echo "Readable mail text has been written in $BASE_DIR/hddmail.txt"
        echo "HTML mail text has been written in $BASE_DIR/hddmailsend.txt"
}

function sendmymail {
        if { [[ $option == "--daily" && $errorfound -eq 1 ]] || [[ $option == "--weekly" ]] || [[ $option == "--sendmail" ]]; }
        then
                logger -t hddmail "Sending SMART notification email"
                sendmail "$dest" < "$BASE_DIR/hddmailsend.txt"

                echo "E-Mail has been send."
        else
                if [[ $option == "--status" ]]
                then
                        cat "$BASE_DIR/hddstatus.txt"
                        echo ""
                        echo ""
                        echo ""
                        cat "$BASE_DIR/hddsummary.txt"
		elif [[ $option == "--summary" ]]
                then
                        cat "$BASE_DIR/hddsummary.txt"
		else
			echo "No E-Mail has been send, no info displayed."
			echo "Enter hddmail --help for more info."
		fi
	fi
	echo "Exiting."
	exit 0

}

function egmailacc {
	echo "" >> /etc/msmtprc
	echo "#Example config by HDDMAIL starts here." >> /etc/msmtprc
	echo "#" >> /etc/msmtprc
	echo "## gmx Account" >> /etc/msmtprc
	echo "#account gmx-some-name" >> /etc/msmtprc
	echo "#host mail.gmx.net" >> /etc/msmtprc
	echo "#port 587" >> /etc/msmtprc
	echo "#from your.user@gmx.de" >> /etc/msmtprc
	echo "#tls on" >> /etc/msmtprc
	echo "#tls_starttls on" >> /etc/msmtprc
	echo "#tls_trust_file /etc/ssl/certs/gmx-smtp.crt" >> /etc/msmtprc
	echo "#auth on" >> /etc/msmtprc
	echo "#user your.user@gmx.de" >> /etc/msmtprc
	echo "##password - some save method to transmit password" >> /etc/msmtprc
	echo "#passwordeval gpg --no-tty -q -d ~/.msmtp-gmx.gpg" >> /etc/msmtprc
	echo "##password - OR some unsave method to transmit password" >> /etc/msmtprc
	echo "#password pAssW0Rd123" >> /etc/msmtprc
	echo "#syslog LOG_MAIL" >> /etc/msmtprc
	echo "#" >> /etc/msmtprc
	echo "#account default : gmx-some-name" >> /etc/msmtprc
	echo "#" >> /etc/msmtprc
}

function gethdds {
	#scanning with lsblk
	all=0
	i=1
	overwrote=0
	first=0
	while [ $all == 0 ]
	do
		hdd="$(lsblk | grep "sd" | cut -c1-3 | grep "sd" | tr '\n' ' '| cut -d' ' -f $i )"
		if [[ $first == 0 ]] && [[ ${hdd} == *"sd"* ]]
		then
			first=1
		elif [[ $first == 1 ]] && [[ ${hdd} == *"sd"* ]]
		then
			if [[ $overwrote == 0 ]]
			then
                                echo $hdd > "$BASE_DIR/listlsblk.txt"
				overwrote=1
			else
                                echo $hdd >> "$BASE_DIR/listlsblk.txt"
			fi
			i=$((i+1))
		elif [[ $first == 1 ]] &&  [[ ${hdd} != *"sd"* ]]
		then
			all=1
		else
			i=$((i+1))
			if [[ $i -gt 20 ]]
			then
				all=2
				echo "Error: No drives could be found."
			fi
		fi
	done

	#scanning with mdadm
	all=0
	i=1
	overwrote=0
	first=0
	while [ $all == 0 ]
	do
		hdd="$(cat /proc/mdstat | grep "sd" | cut -d' ' -f $i | cut -c1-3 | grep "sd")"
		if [[ $first == 0 ]] && [[ ${hdd} == *"sd"* ]]
		then
			first=1
		elif [[ $first == 1 ]] && [[ ${hdd} == *"sd"* ]]
		then
			if [[ $overwrote == 0 ]]
			then
                                echo $hdd > "$BASE_DIR/listmdadm.txt"
				overwrote=1
			else
                                echo $hdd >> "$BASE_DIR/listmdadm.txt"
			fi
			i=$((i+1))
		elif [[ $first == 1 ]] &&  [[ ${hdd} != *"sd"* ]]
		then
			all=1
		else
			i=$((i+1))
			if [[ $i -gt 20 ]]
			then
				all=2
				echo "Error: No drives could be found."
			fi
		fi
	done
}


function writeHddmail {

                mkdir -p "$BASE_DIR" > /dev/null
echo \#\!/bin/bash > "$BASE_DIR/hddmail"
echo "IFS=$'\n'" >> "$BASE_DIR/hddmail"
echo "" >> "$BASE_DIR/hddmail"
echo ": '	HDDMAIL v.1.2 by admiral-vulcan
 2020" >> "$BASE_DIR/hddmail"
echo "" >> "$BASE_DIR/hddmail"
echo "	Changelog:" >> "$BASE_DIR/hddmail"
echo "	1.1	FIXED	changed crontab." >> "$BASE_DIR/hddmail"
echo "	1.2	FIXED	\"Error: No error\" - error" >> "$BASE_DIR/hddmail"
echo "	1.2	ADDED	tab completion in bash" >> "$BASE_DIR/hddmail"
echo "" >> "$BASE_DIR/hddmail"
echo "'" >> "$BASE_DIR/hddmail"
echo "" >> "$BASE_DIR/hddmail"
echo "dupe_script=\$(ps -ef | grep \"hddexec\" | grep -v grep | wc -l)" >> "$BASE_DIR/hddmail"
echo "" >> "$BASE_DIR/hddmail"
echo "if [ \${dupe_script} -gt 3 ]" >> "$BASE_DIR/hddmail"
echo "then" >> "$BASE_DIR/hddmail"
echo "    echo -e \"HDDMAIL läuft bereits.\"" >> "$BASE_DIR/hddmail"
echo "    exit 0" >> "$BASE_DIR/hddmail"
echo "else" >> "$BASE_DIR/hddmail"
echo "	$BASE_DIR/hddexec \"\$@\"" >> "$BASE_DIR/hddmail"
echo "	exit 0" >> "$BASE_DIR/hddmail"
echo "fi" >> "$BASE_DIR/hddmail"
chmod 755 "$BASE_DIR/hddmail"

}



chkhome
chkln
if ! complete -p hddmail >/dev/null 2>&1
then
        complete -W '-h --help --sendmail --weekly --daily --config --viewcfg --status --summary --resetstore' hddmail
fi
chkoption
modejumper
chkconfig
readconfig
domagic
makemail
sendmymail
